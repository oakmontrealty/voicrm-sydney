// Real-time call quality monitoring endpoint\n\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabase = createClient(\n  process.env.SUPABASE_URL,\n  process.env.SUPABASE_SERVICE_KEY\n);\n\nexport default async function handler(req, res) {\n  if (req.method === 'POST') {\n    // Store quality metrics\n    try {\n      const {\n        call_sid,\n        phone_number_id,\n        agent_id,\n        mos_score,\n        latency_ms,\n        jitter_ms,\n        packet_loss_percent,\n        connection_type,\n        device_type,\n        webrtc_stats\n      } = req.body;\n\n      await supabase\n        .from('call_quality_metrics')\n        .insert({\n          call_sid,\n          phone_number_id,\n          agent_id,\n          mos_score,\n          latency_ms,\n          jitter_ms,\n          packet_loss_percent,\n          connection_type,\n          device_type,\n          webrtc_stats\n        });\n\n      // Check for SLO breaches\n      const breaches = [];\n      if (mos_score < 4.2) breaches.push('MOS below 4.2');\n      if (latency_ms > 150) breaches.push('Latency above 150ms');\n      if (jitter_ms > 20) breaches.push('Jitter above 20ms');\n      if (packet_loss_percent > 1.0) breaches.push('Packet loss above 1%');\n\n      if (breaches.length > 0) {\n        // Alert system for SLO breaches\n        console.warn('SLO Breach Alert:', {\n          call_sid,\n          agent_id,\n          breaches,\n          metrics: { mos_score, latency_ms, jitter_ms, packet_loss_percent }\n        });\n        \n        // Update phone number health score if consistent issues\n        if (phone_number_id && breaches.length >= 2) {\n          await supabase\n            .from('phone_numbers')\n            .update({\n              health_score: supabase.rpc('decrease_health_score', {\n                number_id: phone_number_id,\n                decrease_amount: 0.05\n              })\n            })\n            .eq('id', phone_number_id);\n        }\n      }\n\n      res.status(200).json({\n        success: true,\n        qualityScore: mos_score,\n        sloBreaches: breaches,\n        recommendedAction: breaches.length > 0 ? 'Check network connection' : null\n      });\n\n    } catch (error) {\n      console.error('Quality metrics storage error:', error);\n      res.status(500).json({ error: error.message });\n    }\n\n  } else if (req.method === 'GET') {\n    // Get real-time quality dashboard data\n    try {\n      const { agent_id, timeframe = '1h' } = req.query;\n\n      let timeFilter = new Date();\n      switch (timeframe) {\n        case '1h': timeFilter.setHours(timeFilter.getHours() - 1); break;\n        case '24h': timeFilter.setDate(timeFilter.getDate() - 1); break;\n        case '7d': timeFilter.setDate(timeFilter.getDate() - 7); break;\n      }\n\n      let query = supabase\n        .from('call_quality_metrics')\n        .select('*')\n        .gte('timestamp', timeFilter.toISOString())\n        .order('timestamp', { ascending: false });\n\n      if (agent_id) {\n        query = query.eq('agent_id', agent_id);\n      }\n\n      const { data: metrics, error } = await query;\n\n      if (error) throw error;\n\n      if (metrics.length === 0) {\n        return res.status(200).json({\n          success: true,\n          timeframe,\n          stats: {\n            totalCalls: 0,\n            avgMOS: 0,\n            avgLatency: 0,\n            avgJitter: 0,\n            avgPacketLoss: 0,\n            sloCompliance: {\n              mos: 100,\n              latency: 100,\n              jitter: 100,\n              packetLoss: 100\n            }\n          },\n          recentMetrics: []\n        });\n      }\n\n      // Calculate aggregated statistics\n      const stats = {\n        totalCalls: metrics.length,\n        avgMOS: (metrics.reduce((sum, m) => sum + (m.mos_score || 0), 0) / metrics.length).toFixed(1),\n        avgLatency: Math.round(metrics.reduce((sum, m) => sum + (m.latency_ms || 0), 0) / metrics.length),\n        avgJitter: Math.round(metrics.reduce((sum, m) => sum + (m.jitter_ms || 0), 0) / metrics.length),\n        avgPacketLoss: (metrics.reduce((sum, m) => sum + (m.packet_loss_percent || 0), 0) / metrics.length).toFixed(2),\n        sloCompliance: {\n          mos: Math.round((metrics.filter(m => m.mos_score >= 4.2).length / metrics.length) * 100),\n          latency: Math.round((metrics.filter(m => m.latency_ms <= 150).length / metrics.length) * 100),\n          jitter: Math.round((metrics.filter(m => m.jitter_ms <= 20).length / metrics.length) * 100),\n          packetLoss: Math.round((metrics.filter(m => m.packet_loss_percent <= 1.0).length / metrics.length) * 100)\n        }\n      };\n\n      res.status(200).json({\n        success: true,\n        timeframe,\n        stats,\n        recentMetrics: metrics.slice(0, 10)\n      });\n\n    } catch (error) {\n      console.error('Quality dashboard error:', error);\n      res.status(500).json({ error: error.message });\n    }\n  } else {\n    res.status(405).json({ error: 'Method not allowed' });\n  }\n}